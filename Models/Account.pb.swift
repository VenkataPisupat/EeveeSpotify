// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: account.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct SpotifyError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var errorCode: Int32 = 0

  var errorMessage: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CustomizeMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: CustomizeMessage.OneOf_Result? = nil

  var response: UcsResponse {
    get {
      if case .response(let v)? = result {return v}
      return UcsResponse()
    }
    set {result = .response(newValue)}
  }

  var error: SpotifyError {
    get {
      if case .error(let v)? = result {return v}
      return SpotifyError()
    }
    set {result = .error(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Result: Equatable {
    case response(UcsResponse)
    case error(SpotifyError)

  #if !swift(>=4.1)
    static func ==(lhs: CustomizeMessage.OneOf_Result, rhs: CustomizeMessage.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.response, .response): return {
        guard case .response(let l) = lhs, case .response(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct UcsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var resolveResult: UcsResponse.OneOf_ResolveResult? = nil

  var resolve: ResolveResponse {
    get {
      if case .resolve(let v)? = resolveResult {return v}
      return ResolveResponse()
    }
    set {resolveResult = .resolve(newValue)}
  }

  var resolveError: SpotifyError {
    get {
      if case .resolveError(let v)? = resolveResult {return v}
      return SpotifyError()
    }
    set {resolveResult = .resolveError(newValue)}
  }

  var accountAttributesResult: UcsResponse.OneOf_AccountAttributesResult? = nil

  var attributes: AccountAttributesResponse {
    get {
      if case .attributes(let v)? = accountAttributesResult {return v}
      return AccountAttributesResponse()
    }
    set {accountAttributesResult = .attributes(newValue)}
  }

  var attributesError: SpotifyError {
    get {
      if case .attributesError(let v)? = accountAttributesResult {return v}
      return SpotifyError()
    }
    set {accountAttributesResult = .attributesError(newValue)}
  }

  var fetchTimeMillis: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ResolveResult: Equatable {
    case resolve(ResolveResponse)
    case resolveError(SpotifyError)

  #if !swift(>=4.1)
    static func ==(lhs: UcsResponse.OneOf_ResolveResult, rhs: UcsResponse.OneOf_ResolveResult) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.resolve, .resolve): return {
        guard case .resolve(let l) = lhs, case .resolve(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resolveError, .resolveError): return {
        guard case .resolveError(let l) = lhs, case .resolveError(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum OneOf_AccountAttributesResult: Equatable {
    case attributes(AccountAttributesResponse)
    case attributesError(SpotifyError)

  #if !swift(>=4.1)
    static func ==(lhs: UcsResponse.OneOf_AccountAttributesResult, rhs: UcsResponse.OneOf_AccountAttributesResult) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.attributes, .attributes): return {
        guard case .attributes(let l) = lhs, case .attributes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.attributesError, .attributesError): return {
        guard case .attributesError(let l) = lhs, case .attributesError(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct ResolveResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var configuration: ResolveConfiguration {
    get {return _configuration ?? ResolveConfiguration()}
    set {_configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  var hasConfiguration: Bool {return self._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  mutating func clearConfiguration() {self._configuration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _configuration: ResolveConfiguration? = nil
}

struct ResolveConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var configurationAssignmentID: String = String()

  var fetchTimeMillis: Int64 = 0

  var assignedValues: [AssignedValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AssignedValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var propertyID: AssignedIdentifier {
    get {return _propertyID ?? AssignedIdentifier()}
    set {_propertyID = newValue}
  }
  /// Returns true if `propertyID` has been explicitly set.
  var hasPropertyID: Bool {return self._propertyID != nil}
  /// Clears the value of `propertyID`. Subsequent reads from it will return its default value.
  mutating func clearPropertyID() {self._propertyID = nil}

  var metadata: AssignedMetadata {
    get {return _metadata ?? AssignedMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var structuredValue: AssignedValue.OneOf_StructuredValue? = nil

  var boolValue: BoolValue {
    get {
      if case .boolValue(let v)? = structuredValue {return v}
      return BoolValue()
    }
    set {structuredValue = .boolValue(newValue)}
  }

  var intValue: IntValue {
    get {
      if case .intValue(let v)? = structuredValue {return v}
      return IntValue()
    }
    set {structuredValue = .intValue(newValue)}
  }

  var enumValue: EnumValue {
    get {
      if case .enumValue(let v)? = structuredValue {return v}
      return EnumValue()
    }
    set {structuredValue = .enumValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_StructuredValue: Equatable {
    case boolValue(BoolValue)
    case intValue(IntValue)
    case enumValue(EnumValue)

  #if !swift(>=4.1)
    static func ==(lhs: AssignedValue.OneOf_StructuredValue, rhs: AssignedValue.OneOf_StructuredValue) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.boolValue, .boolValue): return {
        guard case .boolValue(let l) = lhs, case .boolValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.intValue, .intValue): return {
        guard case .intValue(let l) = lhs, case .intValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.enumValue, .enumValue): return {
        guard case .enumValue(let l) = lhs, case .enumValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _propertyID: AssignedIdentifier? = nil
  fileprivate var _metadata: AssignedMetadata? = nil
}

struct AssignedIdentifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scope: String = String()

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AssignedMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var policyID: Int64 = 0

  var externalRealm: String = String()

  var externalRealmID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BoolValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct IntValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct EnumValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AccountAttributesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountAttributes: Dictionary<String,AccountAttribute> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AccountAttribute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: AccountAttribute.OneOf_Value? = nil

  var boolValue: Bool {
    get {
      if case .boolValue(let v)? = value {return v}
      return false
    }
    set {value = .boolValue(newValue)}
  }

  var longValue: Int64 {
    get {
      if case .longValue(let v)? = value {return v}
      return 0
    }
    set {value = .longValue(newValue)}
  }

  var stringValue: String {
    get {
      if case .stringValue(let v)? = value {return v}
      return String()
    }
    set {value = .stringValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case boolValue(Bool)
    case longValue(Int64)
    case stringValue(String)

  #if !swift(>=4.1)
    static func ==(lhs: AccountAttribute.OneOf_Value, rhs: AccountAttribute.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.boolValue, .boolValue): return {
        guard case .boolValue(let l) = lhs, case .boolValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.longValue, .longValue): return {
        guard case .longValue(let l) = lhs, case .longValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stringValue, .stringValue): return {
        guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct BootstrapMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var wrapper: CustomizationMessageWrapper {
    get {return _wrapper ?? CustomizationMessageWrapper()}
    set {_wrapper = newValue}
  }
  /// Returns true if `wrapper` has been explicitly set.
  var hasWrapper: Bool {return self._wrapper != nil}
  /// Clears the value of `wrapper`. Subsequent reads from it will return its default value.
  mutating func clearWrapper() {self._wrapper = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _wrapper: CustomizationMessageWrapper? = nil
}

struct CustomizationMessageWrapper {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var oneMoreWrapper: CustomizationMessageOneMoreWrapper {
    get {return _oneMoreWrapper ?? CustomizationMessageOneMoreWrapper()}
    set {_oneMoreWrapper = newValue}
  }
  /// Returns true if `oneMoreWrapper` has been explicitly set.
  var hasOneMoreWrapper: Bool {return self._oneMoreWrapper != nil}
  /// Clears the value of `oneMoreWrapper`. Subsequent reads from it will return its default value.
  mutating func clearOneMoreWrapper() {self._oneMoreWrapper = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _oneMoreWrapper: CustomizationMessageOneMoreWrapper? = nil
}

struct CustomizationMessageOneMoreWrapper {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: CustomizeMessage {
    get {return _message ?? CustomizeMessage()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _message: CustomizeMessage? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension SpotifyError: @unchecked Sendable {}
extension CustomizeMessage: @unchecked Sendable {}
extension CustomizeMessage.OneOf_Result: @unchecked Sendable {}
extension UcsResponse: @unchecked Sendable {}
extension UcsResponse.OneOf_ResolveResult: @unchecked Sendable {}
extension UcsResponse.OneOf_AccountAttributesResult: @unchecked Sendable {}
extension ResolveResponse: @unchecked Sendable {}
extension ResolveConfiguration: @unchecked Sendable {}
extension AssignedValue: @unchecked Sendable {}
extension AssignedValue.OneOf_StructuredValue: @unchecked Sendable {}
extension AssignedIdentifier: @unchecked Sendable {}
extension AssignedMetadata: @unchecked Sendable {}
extension BoolValue: @unchecked Sendable {}
extension IntValue: @unchecked Sendable {}
extension EnumValue: @unchecked Sendable {}
extension AccountAttributesResponse: @unchecked Sendable {}
extension AccountAttribute: @unchecked Sendable {}
extension AccountAttribute.OneOf_Value: @unchecked Sendable {}
extension BootstrapMessage: @unchecked Sendable {}
extension CustomizationMessageWrapper: @unchecked Sendable {}
extension CustomizationMessageOneMoreWrapper: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension SpotifyError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SpotifyError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "errorCode"),
    2: .same(proto: "errorMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != 0 {
      try visitor.visitSingularInt32Field(value: self.errorCode, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpotifyError, rhs: SpotifyError) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CustomizeMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CustomizeMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "response"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UcsResponse?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .response(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .response(v)
        }
      }()
      case 2: try {
        var v: SpotifyError?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .response?: try {
      guard case .response(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CustomizeMessage, rhs: CustomizeMessage) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UcsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UcsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resolve"),
    2: .same(proto: "resolveError"),
    3: .same(proto: "attributes"),
    4: .same(proto: "attributesError"),
    5: .same(proto: "fetchTimeMillis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: ResolveResponse?
        var hadOneofValue = false
        if let current = self.resolveResult {
          hadOneofValue = true
          if case .resolve(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resolveResult = .resolve(v)
        }
      }()
      case 2: try {
        var v: SpotifyError?
        var hadOneofValue = false
        if let current = self.resolveResult {
          hadOneofValue = true
          if case .resolveError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resolveResult = .resolveError(v)
        }
      }()
      case 3: try {
        var v: AccountAttributesResponse?
        var hadOneofValue = false
        if let current = self.accountAttributesResult {
          hadOneofValue = true
          if case .attributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.accountAttributesResult = .attributes(v)
        }
      }()
      case 4: try {
        var v: SpotifyError?
        var hadOneofValue = false
        if let current = self.accountAttributesResult {
          hadOneofValue = true
          if case .attributesError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.accountAttributesResult = .attributesError(v)
        }
      }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.fetchTimeMillis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.resolveResult {
    case .resolve?: try {
      guard case .resolve(let v)? = self.resolveResult else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .resolveError?: try {
      guard case .resolveError(let v)? = self.resolveResult else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    switch self.accountAttributesResult {
    case .attributes?: try {
      guard case .attributes(let v)? = self.accountAttributesResult else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .attributesError?: try {
      guard case .attributesError(let v)? = self.accountAttributesResult else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if self.fetchTimeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.fetchTimeMillis, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UcsResponse, rhs: UcsResponse) -> Bool {
    if lhs.resolveResult != rhs.resolveResult {return false}
    if lhs.accountAttributesResult != rhs.accountAttributesResult {return false}
    if lhs.fetchTimeMillis != rhs.fetchTimeMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ResolveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ResolveResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "configuration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ResolveResponse, rhs: ResolveResponse) -> Bool {
    if lhs._configuration != rhs._configuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ResolveConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ResolveConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "configurationAssignmentId"),
    2: .same(proto: "fetchTimeMillis"),
    3: .same(proto: "assignedValues"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.configurationAssignmentID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.fetchTimeMillis) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.assignedValues) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.configurationAssignmentID.isEmpty {
      try visitor.visitSingularStringField(value: self.configurationAssignmentID, fieldNumber: 1)
    }
    if self.fetchTimeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.fetchTimeMillis, fieldNumber: 2)
    }
    if !self.assignedValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assignedValues, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ResolveConfiguration, rhs: ResolveConfiguration) -> Bool {
    if lhs.configurationAssignmentID != rhs.configurationAssignmentID {return false}
    if lhs.fetchTimeMillis != rhs.fetchTimeMillis {return false}
    if lhs.assignedValues != rhs.assignedValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AssignedValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AssignedValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "propertyId"),
    2: .same(proto: "metadata"),
    3: .same(proto: "boolValue"),
    4: .same(proto: "intValue"),
    5: .same(proto: "enumValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._propertyID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 3: try {
        var v: BoolValue?
        var hadOneofValue = false
        if let current = self.structuredValue {
          hadOneofValue = true
          if case .boolValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.structuredValue = .boolValue(v)
        }
      }()
      case 4: try {
        var v: IntValue?
        var hadOneofValue = false
        if let current = self.structuredValue {
          hadOneofValue = true
          if case .intValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.structuredValue = .intValue(v)
        }
      }()
      case 5: try {
        var v: EnumValue?
        var hadOneofValue = false
        if let current = self.structuredValue {
          hadOneofValue = true
          if case .enumValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.structuredValue = .enumValue(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._propertyID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.structuredValue {
    case .boolValue?: try {
      guard case .boolValue(let v)? = self.structuredValue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .intValue?: try {
      guard case .intValue(let v)? = self.structuredValue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .enumValue?: try {
      guard case .enumValue(let v)? = self.structuredValue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AssignedValue, rhs: AssignedValue) -> Bool {
    if lhs._propertyID != rhs._propertyID {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.structuredValue != rhs.structuredValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AssignedIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AssignedIdentifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scope) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AssignedIdentifier, rhs: AssignedIdentifier) -> Bool {
    if lhs.scope != rhs.scope {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AssignedMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AssignedMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "policyId"),
    2: .same(proto: "externalRealm"),
    3: .same(proto: "externalRealmId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.policyID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.externalRealm) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.externalRealmID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.policyID != 0 {
      try visitor.visitSingularInt64Field(value: self.policyID, fieldNumber: 1)
    }
    if !self.externalRealm.isEmpty {
      try visitor.visitSingularStringField(value: self.externalRealm, fieldNumber: 2)
    }
    if self.externalRealmID != 0 {
      try visitor.visitSingularInt64Field(value: self.externalRealmID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AssignedMetadata, rhs: AssignedMetadata) -> Bool {
    if lhs.policyID != rhs.policyID {return false}
    if lhs.externalRealm != rhs.externalRealm {return false}
    if lhs.externalRealmID != rhs.externalRealmID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BoolValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BoolValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != false {
      try visitor.visitSingularBoolField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BoolValue, rhs: BoolValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IntValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "IntValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IntValue, rhs: IntValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EnumValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EnumValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: EnumValue, rhs: EnumValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AccountAttributesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AccountAttributesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountAttributes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,AccountAttribute>.self, value: &self.accountAttributes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountAttributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,AccountAttribute>.self, value: self.accountAttributes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AccountAttributesResponse, rhs: AccountAttributesResponse) -> Bool {
    if lhs.accountAttributes != rhs.accountAttributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AccountAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AccountAttribute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "boolValue"),
    3: .same(proto: "longValue"),
    4: .same(proto: "stringValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .boolValue(v)
        }
      }()
      case 3: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .longValue(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .stringValue(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .boolValue?: try {
      guard case .boolValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .longValue?: try {
      guard case .longValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }()
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AccountAttribute, rhs: AccountAttribute) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BootstrapMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BootstrapMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "wrapper"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._wrapper) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._wrapper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BootstrapMessage, rhs: BootstrapMessage) -> Bool {
    if lhs._wrapper != rhs._wrapper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CustomizationMessageWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CustomizationMessageWrapper"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "oneMoreWrapper"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._oneMoreWrapper) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._oneMoreWrapper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CustomizationMessageWrapper, rhs: CustomizationMessageWrapper) -> Bool {
    if lhs._oneMoreWrapper != rhs._oneMoreWrapper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CustomizationMessageOneMoreWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CustomizationMessageOneMoreWrapper"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CustomizationMessageOneMoreWrapper, rhs: CustomizationMessageOneMoreWrapper) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
